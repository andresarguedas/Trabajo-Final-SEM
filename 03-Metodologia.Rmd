\subsection{Casos de simulación}

\subsection{Generación de datos con kurtosis}

Los datos fueron simulados mediante la función `simulateData()` del paquete `lavaan` [@lavaan], el cual utiliza el método propuesto por Vale y Maurelli [@Vale1983] para la simulación de datos no normales multivariados. Este método, comúnmente conocido como VM, se basa en el método propuesto por Fleishman [@Fleishman1978], el cual, con base en una variable aleatoria distribuida como una normal estándar, permite simular una variable con un promedio, variancia, asimetría y kurtosis dada. El método VM permite especificar, adicionalmente, correlaciones entre las variables a estimar. Para utilizar el método de Fleishman, para generar una cierta variable aleatoria $Y$, se utiliza la siguiente ecuación:

\begin{equation} \label{eq:defY}
  Y = a + bX + cX^2 + d X^3
\end{equation}

donde $X \sim \mathcal{N} (0,1)$. Es decir, se puede generar una variable no normal $Y$, con sus primeros cuatro momentos iguales a valores especificados, con base en los valores $a$, $b$, $c$ y $d$ de la ecuación \ref{eq:defY}, con base en una variable normal estándar $X$ hasta su tercer potencia. Luego, para poder obtener los valores de $a$, $b$, $c$ y $d$, se necesitan resolver las siguientes ecuaciones de forma simultánea:

\begin{align}
  b^2 + 6bd + 2c^2 + 15d^2 -1 & = 0 \\
  2c (b^2 + 24bd + 105d^2 + 2) - \gamma_1 & = 0 \\
  24 \left(bd + c^2 (1 + b^2 + 28bd) + d^2 (12 + 48bd + 141c^2 + 225d^2) \right) - \gamma_2 & = 0
\end{align}

donde $\gamma_1$ es la asimetría deseada y $\gamma_2$ es la kurtosis deseada, además se define $a = -c$. Con base en las constantes calculadas $a$, $b$, $c$ y $d$, además de una variable normal estándar, se puede simular variables no normales. Para poder generalizar el método de Fleishman a variables aleatorias multivariantes, Vale y Maurelli proponen una generalización. Esta se basa, para el caso bivariado, en la generación de dos variables aleatorias independientes, $X_1, X_2 \sim \mathcal{N} (0,1)$, para la cuales se obtienen las constantes $a$, $b$, $c$ y $d$, para cada una de dichas variables, como se describe en el método de Fleishman, obteniendo así el vector $w^\prime_1 = (a_1, b_1, c_1, d_1)$, para el caso de $X_1$, y el vector $w^\prime_2 = (a_2, b_2, c_2, d_2)$, para el caso de $X_2$. Además, se definen los vectores $x_1^\prime = (1, X_1, X_1^2, X_1^3)$ y $x_2^\prime = (1, X_2, X_2^2, X_2^3)$. Por lo tanto, se pueden crear variables no normales, $Y_1$ y $Y_2$, como:

\begin{align*}
  Y_1 & = w_1^\prime x_1 \\
  Y_2 & = w_2^\prime x_2
\end{align*}

donde se puede verificar que:

\begin{align*}
  r_{Y_1, Y_2} = & \rho_{X_1, X_2} (b_1 b_2 + 3b_1 d_2 + 3d_1 b_2 + 9 d_1 d_2) \\
  & + \rho_{X_1, X_2}^2 (2 c_1 c_2) + \rho_{X_1, X_2}^3 (6 d_1 d_2)
\end{align*}

Y resolviendo esta ecuación en términos de $\rho_{X_1, X_2}$ se puede obtener una matriz de correlaciones para generar datos normales multivariados, que pueden ser transformados en variables no normales mediante el método de Fleishman.

\subsection{Modelo teórico a estimar}

\subsection{Medidas de bondad de ajuste}

\subsection{Simulación y estimación}

La simulación de los datos, junto con la estimación de los modelos, se realizó mediante el paquete `lavaan` [@lavaan] usando el software R [@R] mediante la interfaz gráfica de RStudio [@RStudio]. Para e manejo de bases de datos y demás visualizaciones fueron utilizados los paquetes `ggplot2`[@ggplot2], `tidyr` [@tidyr], `dplyr` [@dplyr], `ggpubr` [@ggpubr], `PerformanceAnalytics` [@PerformanceAnalytics] y `kableExtra` [@kableExtra].

Para poder realizar la simulación deben seguirse varios pasos. Lo primero es definir el modelo teórico poblacional que van a seguir los datos simulados, como se describió en secciones anteriores este modelo cuenta con dos variables exógenas y una endógena, cada una con tres variables indicadoras. Los datos se generan mediante la función `simulateData()` la cuál requiere especificar varios argumentos, uno de ellos es el modelo poblacional, cuya sintaxis puede encontrarse en el \ref{modelo}. Los otros dos argumentos a especificar son el tamaño de muestra deseado y el nivel de kurtosis de interés, la definición de estos escenarios se obtiene mediante el \ref{escenarios} y se muestran en el cuadro \ref{tab:escenarios}:

```{r, echo=FALSE}
cuadro <- expand.grid(kurtosis=c(0, 0.62, 6.65, 21.41, 13.92), n=c(50, 100, 200, 400, 800))

cbind(cuadro[1:5,], cuadro[6:10,], cuadro[11:15,], cuadro[16:20,], cuadro[21:25,]) %>% 
  kable(., "latex", booktabs=T,caption="\\label{tab:escenarios}Escenarios de simulación") %>% 
footnote(general = "Elaboración propia a partir del estudio de la Universidad de California (2008)", general_title = "Fuente:", title_format = "italic",
         footnote_as_chunk = T) %>% 
    kable_styling(latex_options = c("striped", "scale_down", "repeat_header", "hold_position"), repeat_header_text = "(cont.)", font_size = 9,full_width = T) 
```

Con estos escenarios definidos, se generaron entonces, para cada combinación de tamaño de muestra y kurtosis un total de 2000 conjuntos de datos para cada uno. La sintaxis necesaria para generar esto se muestra en el \ref{simulacion}. Una vez que se obtuvieron estos conjuntos de datos, el siguiente paso es realizar la estimación de los SEM con cada uno de ellos; para ello es necesario definir un modelo de una forma similar a como se indicó en el \ref{modelo}, pero esta vez sin los valores de las cargas factoriales, pues se busca conocer las estimaciones a partir de los datos generados, este proceso se muestra en el \ref{modelos_sem}.



